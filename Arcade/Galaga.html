<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galaga Retro Replica</title>
    <style>
        :root {
            --arcade-red: #ff0000;
            --arcade-blue: #0000ff;
            --arcade-yellow: #ffff00;
            --bg-color: #050505;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 3 / 4;
            background-color: var(--bg-color);
            box-shadow: 0 0 50px rgba(0,0,0,0.8), 0 0 10px rgba(255,255,255,0.1);
            border: 4px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 10px; left: 10px; right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            text-shadow: 2px 2px #000;
            pointer-events: none;
            z-index: 10;
        }

        .stat-label { color: var(--arcade-red); font-weight: bold; }
        .stat-value { color: #fff; }

        #overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
        }

        button {
            background: var(--arcade-red);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 4px;
            box-shadow: 0 4px 0 #800;
        }

        #controls-hint {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: #555;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui">
        <div>
            <div class="stat-label">1UP</div>
            <div id="score" class="stat-value">00</div>
        </div>
        <div style="text-align: center;">
            <div class="stat-label">STAGE</div>
            <div id="wave-display" class="stat-value">1</div>
        </div>
        <div>
            <div class="stat-label">HIGH SCORE</div>
            <div id="high-score" class="stat-value">20000</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="overlay">
        <h1 style="color: var(--arcade-yellow); margin: 0; font-size: 40px;">GALAGA</h1>
        <p style="color: var(--arcade-blue); letter-spacing: 2px;">REPLICA MISSION</p>
        <div id="msg" style="margin-top: 10px;">READY PLAYER ONE</div>
        <button id="start-btn">START</button>
    </div>

    <div id="controls-hint">ARROWS: MOVE | SPACE: FIRE</div>
</div>

<script>
window.addEventListener('keydown', (e) => { if(e.key === 'Escape') window.parent.postMessage('exitGame', '*'); });
   This ensures the game tells the launcher "Hey, the user wants to quit!"
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('high-score');
    const waveEl = document.getElementById('wave-display');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start-btn');

    // Arcade Resolution
    const V_WIDTH = 224;
    const V_HEIGHT = 288;
    canvas.width = V_WIDTH;
    canvas.height = V_HEIGHT;

    // Game State
    let score = 0;
    let wave = 1;
    let highScore = localStorage.getItem('galaga_high') || 20000;
    let nextExtraLifeScore = 10000; // Track 1UP threshold
    highScoreEl.innerText = highScore;
    
    let gameActive = false;
    let keys = {};
    let stars = [];
    let bullets = [];
    let enemies = [];
    let explosions = [];
    let enemyDirection = 1;
    let fleetX = 25;

    // ====== ASSETS & CLASSES ======

    class Star {
        constructor() {
            this.x = Math.random() * V_WIDTH;
            this.y = Math.random() * V_HEIGHT;
            this.speed = 0.5 + Math.random() * 1.5;
            this.color = ['#fff', '#66f', '#f66', '#ff6'][Math.floor(Math.random() * 4)];
        }
        update() {
            this.y += this.speed;
            if (this.y > V_HEIGHT) {
                this.y = 0;
                this.x = Math.random() * V_WIDTH;
            }
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, 1, 1);
        }
    }

    function drawGalaxip(x, y, scale = 1) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        // Tip
        ctx.fillStyle = 'yellow'; ctx.fillRect(7, 0, 1, 2);
        // Main Body
        ctx.fillStyle = 'white';
        ctx.fillRect(6, 2, 3, 2);
        ctx.fillRect(5, 4, 5, 2);
        ctx.fillRect(4, 6, 7, 6);
        ctx.fillRect(6, 12, 3, 2);
        // Cockpit
        ctx.fillStyle = '#00ffff'; ctx.fillRect(7, 5, 1, 3);
        // Fins (Red)
        ctx.fillStyle = 'red';
        ctx.fillRect(1, 8, 2, 7);
        ctx.fillRect(12, 8, 2, 7);
        ctx.fillRect(3, 10, 1, 4);
        ctx.fillRect(11, 10, 1, 4);
        // Details
        ctx.fillStyle = 'white';
        ctx.fillRect(2, 13, 1, 2);
        ctx.fillRect(12, 13, 1, 2);
        ctx.restore();
    }

    const player = {
        x: V_WIDTH / 2 - 7.5,
        y: V_HEIGHT - 30,
        width: 15,
        height: 15,
        speed: 2.5,
        lastShot: 0,
        lives: 3,
        respawnTimer: 0,
        invincibleTimer: 0,
        visible: true,
        draw() {
            if (!this.visible) return;
            if (this.invincibleTimer > 0 && Math.floor(Date.now() / 80) % 2 === 0) return;
            drawGalaxip(this.x, this.y);
        }
    };

    class Enemy {
        constructor(col, row, type) {
            this.type = type; 
            this.width = 15;
            this.height = 14;
            this.offsetX = col * 18;
            this.offsetY = row * 16;
            this.x = fleetX + this.offsetX;
            this.y = 40 + this.offsetY;
            this.state = 'formation';
            this.diveProgress = 0;
            this.points = [50, 80, 150][type];
            this.animFrame = Math.random() * 10;
            this.beamTimer = 0;
        }

        update() {
            this.animFrame += 0.12;
            if (this.state === 'formation') {
                this.x = fleetX + this.offsetX;
                this.y = 40 + this.offsetY;
                if (Math.random() > 0.9996 - (wave * 0.0001)) this.state = 'diving';
            } else if (this.state === 'diving') {
                this.diveProgress += 0.02;
                this.y += 2.2 + (wave * 0.1);
                this.x += Math.sin(this.diveProgress * 5) * 2.5;

                if (this.x < -20) this.x = V_WIDTH + 10;
                if (this.x > V_WIDTH + 20) this.x = -10;

                if (wave > 3 && this.type === 2 && this.y > 140 && this.y < 160 && this.beamTimer === 0) {
                    if (Math.random() > 0.85) {
                        this.state = 'beaming';
                        this.beamTimer = 180; 
                    }
                }

                if (this.y > V_HEIGHT) {
                    this.y = -20;
                    this.state = 'formation';
                    this.diveProgress = 0;
                }
            } else if (this.state === 'beaming') {
                this.beamTimer--;
                const beamMaxHeight = 135;
                const beamBottom = this.y + this.height + beamMaxHeight;
                const beamHalfWidthAtShip = 10 + (35 * ((player.y - (this.y + this.height)) / beamMaxHeight));

                if (player.visible && !player.invincibleTimer &&
                    player.y > this.y + this.height && 
                    player.y < beamBottom &&
                    Math.abs((player.x + 7) - (this.x + 7)) < beamHalfWidthAtShip) {
                    
                    if (this.beamTimer < 140) {
                        playerHit();
                    }
                }
                
                if (this.beamTimer <= 0) {
                    this.state = 'diving';
                }
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            const flap = Math.sin(this.animFrame) > 0;
            
            if (this.type === 0) { // BEE (Zako)
                // Head (Yellow)
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-2, -6, 4, 2);
                // Body (Blue)
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(-3, -4, 6, 6);
                ctx.fillRect(-1, 2, 2, 3);
                // Wings (Cyan)
                ctx.fillStyle = '#00ffff';
                if (flap) {
                    ctx.fillRect(-6, -3, 3, 5);
                    ctx.fillRect(3, -3, 3, 5);
                    ctx.fillRect(-7, -1, 1, 2);
                    ctx.fillRect(6, -1, 1, 2);
                } else {
                    ctx.fillRect(-7, -2, 4, 3);
                    ctx.fillRect(3, -2, 4, 3);
                    ctx.fillRect(-8, -1, 1, 1);
                    ctx.fillRect(7, -1, 1, 1);
                }
            } 
            else if (this.type === 1) { // BUTTERFLY (Goei)
                // Body (Red)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-2, -5, 4, 9);
                ctx.fillRect(-4, 0, 8, 2);
                // Wings (White)
                ctx.fillStyle = 'white';
                if (flap) {
                    ctx.fillRect(-6, -4, 4, 9);
                    ctx.fillRect(2, -4, 4, 9);
                    ctx.fillRect(-4, -6, 2, 2);
                    ctx.fillRect(2, -6, 2, 2);
                } else {
                    ctx.fillRect(-7, -3, 5, 6);
                    ctx.fillRect(2, -3, 5, 6);
                    ctx.fillRect(-3, -6, 1, 1);
                    ctx.fillRect(2, -6, 1, 1);
                }
            } 
            else { // BOSS GALAGA (Midori)
                // Main Shell (Green)
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-6, -4, 12, 9);
                ctx.fillRect(-4, -6, 8, 2);
                // Pincers (Yellow)
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-5, -7, 2, 3);
                ctx.fillRect(3, -7, 2, 3);
                // Core (Purple/Magenta)
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(-2, -2, 4, 4);
                // Detail
                ctx.fillStyle = 'black';
                ctx.fillRect(-1, -1, 2, 2);
            }
            ctx.restore();

            if (this.state === 'beaming') {
                this.drawTractorBeam();
            }
        }

        drawTractorBeam() {
            ctx.save();
            const beamX = this.x + this.width / 2;
            const beamY = this.y + this.height;
            const ringCount = 7; 
            const beamMaxHeight = 135;
            const startWidth = 10;
            const endWidth = 55;
            const cycle = Math.floor(Date.now() / 70) % 3;
            const colors = ['#00ffff', '#0077ff', '#ffffff'];
            ctx.globalAlpha = 0.7;
            for (let i = 0; i < ringCount; i++) {
                const ratio = i / (ringCount - 1);
                const width = startWidth + (endWidth - startWidth) * ratio;
                const currentY = beamY + (ratio * beamMaxHeight);
                const colorIndex = (i + cycle) % 3;
                ctx.fillStyle = colors[colorIndex];
                ctx.beginPath();
                ctx.ellipse(beamX, currentY, width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                if (i < ringCount - 1) {
                    const nextRatio = (i + 1) / (ringCount - 1);
                    const nextWidth = startWidth + (endWidth - startWidth) * nextRatio;
                    const nextY = beamY + (nextRatio * beamMaxHeight);
                    ctx.beginPath();
                    ctx.strokeStyle = colors[colorIndex];
                    ctx.setLineDash([2, 2]); 
                    ctx.lineWidth = 1;
                    ctx.moveTo(beamX - width / 2, currentY);
                    ctx.lineTo(beamX - nextWidth / 2, nextY);
                    ctx.moveTo(beamX + width / 2, currentY);
                    ctx.lineTo(beamX + nextWidth / 2, nextY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            ctx.restore();
        }
    }

    // ====== CORE ENGINE ======

    function spawnExplosion(x, y, type = 'enemy') {
        if (type === 'player') {
            // Complex particle burst for player
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                explosions.push({
                    x, y, 
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 40 + Math.random() * 20,
                    type: 'particle',
                    color: i % 2 === 0 ? 'white' : 'red'
                });
            }
        } else {
            // Standard square burst for enemies
            explosions.push({x, y, life: 15, type: 'standard'});
        }
    }

    function initEnemies() {
        enemies = [];
        fleetX = 25;
        for (let i = 0; i < 4; i++) enemies.push(new Enemy(3 + i, 0, 2));
        for (let r = 1; r < 3; r++) {
            for (let i = 0; i < 8; i++) enemies.push(new Enemy(1 + i, r, 1));
        }
        for (let r = 3; r < 5; r++) {
            for (let i = 0; i < 10; i++) enemies.push(new Enemy(0 + i, r, 0));
        }
    }

    function initGame() {
        stars = Array.from({length: 50}, () => new Star());
        wave = 1;
        score = 0;
        nextExtraLifeScore = 10000; // Reset 1UP threshold
        player.lives = 3;
        player.x = V_WIDTH / 2 - 7.5;
        player.visible = true;
        player.respawnTimer = 0;
        player.invincibleTimer = 0;
        initEnemies();
        gameActive = true;
        overlay.style.display = 'none';
        waveEl.innerText = wave;
    }

    function playerHit() {
        spawnExplosion(player.x + 7, player.y + 7, 'player');
        player.lives--;
        player.visible = false;
        player.respawnTimer = 120;
        if (player.lives < 0) gameOver();
    }

    function update() {
        if (!gameActive) return;

        if (player.respawnTimer > 0) {
            player.respawnTimer--;
            if (player.respawnTimer === 0 && player.lives >= 0) {
                player.visible = true;
                player.x = V_WIDTH / 2 - 7.5;
                player.invincibleTimer = 150; 
            }
        }

        if (player.invincibleTimer > 0) player.invincibleTimer--;

        if (player.visible) {
            if (keys["ArrowLeft"] && player.x > 5) player.x -= player.speed;
            if (keys["ArrowRight"] && player.x < V_WIDTH - player.width - 5) player.x += player.speed;
            if (keys["Space"]) {
                const now = Date.now();
                if (now - player.lastShot > 250) {
                    bullets.push({x: player.x + 7, y: player.y, w: 2, h: 6});
                    player.lastShot = now;
                }
            }
        }

        bullets.forEach((b, i) => {
            b.y -= 4.5;
            if (b.y < -10) bullets.splice(i, 1);
        });

        stars.forEach(s => s.update());
        fleetX += enemyDirection * (0.4 + (wave * 0.05));
        
        let minX = V_WIDTH, maxX = 0, formationCount = 0;
        enemies.forEach(e => {
            if (e.state === 'formation') {
                formationCount++;
                const ex = fleetX + e.offsetX;
                if (ex < minX) minX = ex;
                if (ex + e.width > maxX) maxX = ex + e.width;
            }
        });

        if (formationCount > 0) {
            if (enemyDirection === 1 && maxX >= V_WIDTH - 8) enemyDirection = -1;
            if (enemyDirection === -1 && minX <= 8) enemyDirection = 1;
        }

        enemies.forEach(e => {
            e.update();
            bullets.forEach((b, bi) => {
                if (b.x < e.x + e.width && b.x + b.w > e.x && b.y < e.y + e.height && b.y + b.h > e.y) {
                    spawnExplosion(e.x + e.width/2, e.y + e.height/2);
                    score += e.points;
                    
                    // 1UP Mechanic
                    if (score >= nextExtraLifeScore) {
                        player.lives++;
                        nextExtraLifeScore += 10000;
                    }
                    
                    enemies.splice(enemies.indexOf(e), 1);
                    bullets.splice(bi, 1);
                }
            });
            if (player.visible && !player.invincibleTimer && e.x < player.x + player.width && e.x + e.width > player.x && e.y < player.y + player.height && e.y + e.height > player.y) {
                playerHit();
            }
        });

        explosions.forEach((ex, i) => {
            if (ex.type === 'particle') {
                ex.x += ex.vx;
                ex.y += ex.vy;
            }
            ex.life--;
            if (ex.life <= 0) explosions.splice(i, 1);
        });

        if (enemies.length === 0) {
            wave++;
            waveEl.innerText = wave;
            initEnemies();
        }
        scoreEl.innerText = score.toString().padStart(2, '0');
    }

    function draw() {
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, V_WIDTH, V_HEIGHT);
        stars.forEach(s => s.draw());
        bullets.forEach(b => {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(b.x, b.y, b.w, b.h);
        });
        enemies.forEach(e => e.draw());
        player.draw();
        for (let i = 0; i < player.lives; i++) {
            drawGalaxip(10 + (i * 18), V_HEIGHT - 18, 0.8);
        }
        explosions.forEach(ex => {
            if (ex.type === 'particle') {
                ctx.fillStyle = ex.color;
                ctx.globalAlpha = ex.life / 60;
                ctx.fillRect(ex.x, ex.y, 2, 2);
                ctx.globalAlpha = 1;
            } else {
                ctx.strokeStyle = '#fff';
                const s = (15 - ex.life) * 1.2;
                ctx.strokeRect(ex.x - s, ex.y - s, s*2, s*2);
                ctx.strokeStyle = '#f00';
                ctx.strokeRect(ex.x - s/2, ex.y - s/2, s, s);
            }
        });
    }

    function gameOver() {
        gameActive = false;
        overlay.style.display = 'flex';
        document.getElementById('msg').innerText = "MISSION FAILED";
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('galaga_high', highScore);
            highScoreEl.innerText = highScore;
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    startBtn.addEventListener('click', initGame);
    loop();
</script>
</body>
</html>
